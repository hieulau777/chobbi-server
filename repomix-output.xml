This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: target, bin, .idea, .settings, .gradle, *.class, *.jar
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.mvn/
  wrapper/
    maven-wrapper.properties
src/
  main/
    java/
      com/
        chobbi/
          server/
            catalog/
              controller/
                ProductController.java
              domain/
                AttributesRule.java
              dto/
                CreateProductAttributeDto.java
                CreateProductImages.java
                CreateProductOptionImages.java
                CreateProductRequest.java
                CreateProductRequestOptionCombination.java
                CreateProductTierDto.java
                CreateProductVariationDto.java
                TierValidationResult.java
              entity/
                AttributesEntity.java
                AttributeValuesEntity.java
                CategoryEntity.java
                OptionsEntity.java
                ProductAttributesEntity.java
                ProductEntity.java
                ProductImagesEntity.java
                TierEntity.java
                VariationEntity.java
                VariationOptionEntity.java
              enums/
                AttributeTypesEnums.java
              services/
                impl/
                  CategoryServicesImpl.java
                  ProductServicesImpl.java
                CategoryServices.java
                ProductServices.java
              cart.json
              create_product.json
              product-detail-buyer.json
              product-update-seller.json
            common/
              BaseEntity.java
            config/
              SecurityConfig.java
            controller/
              AuthenticationController.java
              CartController.java
              CheckoutController.java
            dto/
              cart/
                CartAddResponseDto.java
                CartProductDto.java
                CartResponseDto.java
                CartShopDto.java
              CategoryDto.java
              OptionDto.java
              OptionRequestDto.java
              ProductDto.java
              ProductVariationDto.java
              TierDto.java
              TierRequestDto.java
              VariationDto.java
              VariationQuantityDto.java
              VariationRequestDto.java
            entity/
              AccountEntity.java
              AccountRolesEntity.java
              CartEntity.java
              CartVariationEntity.java
              RolesEntity.java
              ShopEntity.java
            enums/
              ProductDtofieldEnums.java
              StatusEnums.java
            exception/
              BusinessException.java
              GlobalExceptionHandler.java
            files/
              config/
                WebConfig.java
              controller/
                FilesController.java
              exception/
                FileUploadExceptionAdvice.java
              message/
                ResponseMessage.java
              services/
                impl/
                  FilesStorageServiceImpl.java
                FilesStorageService.java
              FolderTypeEnum.java
            repo/
              AccountRepo.java
              AttributesRepo.java
              AttributeValuesRepo.java
              CartRepo.java
              CartVariationRepo.java
              CategoryRepo.java
              OptionsRepo.java
              ProductRepo.java
              ShopRepo.java
              TierRepo.java
              VariationOptionRepo.java
              VariationRepo.java
            ServerApplication.java
    resources/
      application.yml
  test/
    java/
      com/
        chobbi/
          server/
            ServerApplicationTests.java
.gitattributes
.gitignore
mvnw
mvnw.cmd
pom.xml
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/main/java/com/chobbi/server/catalog/dto/CreateProductImages.java">
package com.chobbi.server.catalog.dto;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class CreateProductImages {
    @NotBlank
    private String name;
    @NotNull
    private Integer order;
}
</file>

<file path="src/main/java/com/chobbi/server/catalog/dto/CreateProductOptionImages.java">
package com.chobbi.server.catalog.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class CreateProductOptionImages {
    private String optionName;
    private String imageName;
}
</file>

<file path="src/main/java/com/chobbi/server/catalog/entity/ProductImagesEntity.java">
package com.chobbi.server.catalog.entity;

import com.chobbi.server.common.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
@Entity(name = "product_images")
public class ProductImagesEntity extends BaseEntity {
    private String path;
    @Column(name = "sort_order")
    private Integer sortOrder;

    @ManyToOne
    @JoinColumn(name = "product_id")
    private ProductEntity productEntity;
}
</file>

<file path="src/main/java/com/chobbi/server/files/config/WebConfig.java">
    package com.chobbi.server.storage.config;

    import org.springframework.beans.factory.annotation.Value;
    import org.springframework.context.annotation.Configuration;
    import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;
    import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

    @Configuration
    public class WebConfig implements WebMvcConfigurer {

    @Value("${file.root-path}")
    private String rootPath;

    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
    registry.addResourceHandler("/static/**")
    .addResourceLocations("file:" + rootPath + "/");
    }
    }
</file>

<file path="src/main/java/com/chobbi/server/files/FolderTypeEnum.java">
package com.chobbi.server.files;

import lombok.Getter;
import lombok.NoArgsConstructor;

@Getter
public enum FolderTypeEnum {
    PRODUCTS("products"),
    AVATARS("avatars"),
    REVIEWS("reviews");

    private final String folderName;

    FolderTypeEnum(String folderName) {
        this.folderName = folderName;
    }
}
</file>

<file path=".mvn/wrapper/maven-wrapper.properties">
wrapperVersion=3.3.4
distributionType=only-script
distributionUrl=https://repo.maven.apache.org/maven2/org/apache/maven/apache-maven/3.9.11/apache-maven-3.9.11-bin.zip
</file>

<file path="src/main/java/com/chobbi/server/catalog/domain/AttributesRule.java">
package com.chobbi.server.catalog.domain;

import com.chobbi.server.catalog.enums.AttributeTypesEnums;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class AttributesRule {
    private boolean required;
    private boolean multipleAllow;
    private boolean customAllow;
    private AttributeTypesEnums type;
}
</file>

<file path="src/main/java/com/chobbi/server/catalog/dto/CreateProductRequestOptionCombination.java">
package com.chobbi.server.catalog.dto;

import jakarta.validation.constraints.NotBlank;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class CreateProductRequestOptionCombination {
    @NotBlank
    private String tierName;
    @NotBlank
    private String optionName;
}
</file>

<file path="src/main/java/com/chobbi/server/catalog/dto/CreateProductTierDto.java">
package com.chobbi.server.catalog.dto;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotEmpty;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class CreateProductTierDto {
    @NotBlank
    private String name;
    @NotEmpty
    private List<@NotBlank String> options;
    @NotNull
    private Boolean hasImages;
}
</file>

<file path="src/main/java/com/chobbi/server/catalog/dto/TierValidationResult.java">
package com.chobbi.server.catalog.dto;

import lombok.Getter;

import java.util.Map;
import java.util.Set;

@Getter
public class TierValidationResult {
    private final Map<String, Set<String>> normalizedTierOptions;
    private final int countCartesian;

    public TierValidationResult(Map<String, Set<String>> normalizedTierOptions, int countCartesian) {
        this.normalizedTierOptions = normalizedTierOptions;
        this.countCartesian = countCartesian;
    }
}
</file>

<file path="src/main/java/com/chobbi/server/catalog/entity/OptionsEntity.java">
package com.chobbi.server.catalog.entity;

import com.chobbi.server.common.BaseEntity;
import jakarta.persistence.*;
import lombok.Data;

import java.util.ArrayList;
import java.util.List;

@Data
@Entity(name = "options")
public class OptionsEntity extends BaseEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
    @Column(name = "img_path")
    private String imgPath;
    @ManyToOne
    @JoinColumn(name = "tier_id")
    private TierEntity tierEntity;

    @OneToMany(mappedBy = "optionsEntity")
    private List<VariationOptionEntity> variationOptions = new ArrayList<>();
}
</file>

<file path="src/main/java/com/chobbi/server/catalog/entity/TierEntity.java">
package com.chobbi.server.catalog.entity;

import com.chobbi.server.common.BaseEntity;
import jakarta.persistence.*;
import lombok.Data;

import java.util.ArrayList;
import java.util.List;

@Data
@Entity(name = "tier")
public class TierEntity extends BaseEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
    @OneToMany(mappedBy = "tierEntity", cascade = CascadeType.ALL)
    private List<OptionsEntity> options = new ArrayList<>();
    @ManyToOne
    @JoinColumn(name = "product_id")
    private ProductEntity productEntity;
}
</file>

<file path="src/main/java/com/chobbi/server/catalog/entity/VariationEntity.java">
package com.chobbi.server.catalog.entity;

import com.chobbi.server.common.BaseEntity;
import com.chobbi.server.enums.StatusEnums;
import jakarta.persistence.*;
import lombok.Data;
import lombok.Getter;
import lombok.Setter;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.List;

@Getter
@Setter
@Entity(name ="variation")
public class VariationEntity extends BaseEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    // private String sku;
    private BigDecimal price;

    @Column(name = "price_discount")
    private BigDecimal priceDiscount;
    private Integer stock;
    //private Long weight;

    @ManyToOne
    @JoinColumn(name = "product_id")
    private ProductEntity productEntity;

    @OneToMany(mappedBy = "variationEntity", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<VariationOptionEntity> variationOptions = new ArrayList<>();

//    @Enumerated(EnumType.STRING)
//    @Column(nullable = false, length = 20)
//    private StatusEnums status = StatusEnums.ACTIVE;
}
</file>

<file path="src/main/java/com/chobbi/server/catalog/entity/VariationOptionEntity.java">
package com.chobbi.server.catalog.entity;

import com.chobbi.server.common.BaseEntity;
import jakarta.persistence.*;
        import lombok.Data;

@Data
@Entity(name = "variation_option")
public class VariationOptionEntity extends BaseEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne
    @JoinColumn(name = "variation_id")
    private VariationEntity variationEntity;

    @ManyToOne
    @JoinColumn(name = "option_id")
    private OptionsEntity optionsEntity;
}
</file>

<file path="src/main/java/com/chobbi/server/catalog/enums/AttributeTypesEnums.java">
package com.chobbi.server.catalog.enums;

public enum AttributeTypesEnums {
    TEXT,
    NUMBER,
    BOOLEAN,
    DATE
}
</file>

<file path="src/main/java/com/chobbi/server/catalog/services/impl/CategoryServicesImpl.java">
package com.chobbi.server.catalog.services.impl;

import com.chobbi.server.catalog.entity.CategoryEntity;
import com.chobbi.server.catalog.services.CategoryServices;
import com.chobbi.server.repo.CategoryRepo;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
public class CategoryServicesImpl implements CategoryServices {
    private final CategoryRepo categoryRepo;

    @Override
    public CategoryEntity getLeafCategoryOrThrow(Long categoryId) {
        CategoryEntity category = categoryRepo.findById(categoryId)
                .orElseThrow(() -> new RuntimeException("Category not found"));

        if (!isLeaf(category.getId())) {
            throw new RuntimeException("Category is not a leaf node");
        }
        return category;
    }
    /**
     * Kiểm tra category có phải là leaf không
     */
    private boolean isLeaf(Long categoryId) {
        return !categoryRepo.existsByParentId(categoryId);
    }
}
</file>

<file path="src/main/java/com/chobbi/server/catalog/services/impl/ProductServicesImpl.java">
package com.chobbi.server.catalog.services.impl;

import com.chobbi.server.catalog.domain.AttributesRule;
import com.chobbi.server.catalog.dto.*;
import com.chobbi.server.catalog.entity.*;
import com.chobbi.server.catalog.enums.AttributeTypesEnums;
import com.chobbi.server.catalog.services.CategoryServices;
import com.chobbi.server.catalog.services.ProductServices;
import com.chobbi.server.entity.ShopEntity;
import com.chobbi.server.repo.*;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.multipart.MultipartFile;

import java.time.LocalDate;
import java.time.format.DateTimeParseException;
import java.util.*;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
public class ProductServicesImpl implements ProductServices {

    private final ProductRepo productRepo;
    private final ShopRepo shopRepo;
    private final CategoryServices categoryServices;
    private final AttributesRepo attributesRepo;
    private final AttributeValuesRepo attributeValuesRepo;
    private final VariationRepo variationRepo;
    private final VariationOptionRepo variationOptionRepo;
    private final OptionsRepo optionRepo;
    private final TierRepo tierRepo;

    @Override
    @Transactional
    public void createProduct(CreateProductRequest req, MultipartFile[] media) {

//
        ShopEntity shopEntity = shopRepo.findById(req.getShopId())
                .orElseThrow(() -> new RuntimeException("Shop not found"));

        CategoryEntity categoryEntity = categoryServices.getLeafCategoryOrThrow(req.getCategoryId());
        ProductEntity product = new ProductEntity();
        product.setName(req.getName());
        product.setShopEntity(shopEntity);
        product.setCategoryEntity(categoryEntity);
        product.setDescription(req.getDescription());

        // validate image upload
        List<CreateProductImages> reqProductImages = req.getImages();
        List<CreateProductOptionImages> reqOptionImages = req.getOptionImages() != null ?
                req.getOptionImages() : Collections.emptyList();
        Set<String> reqImageNames = new HashSet<>();
        for (CreateProductImages item : reqProductImages) {
            if (!reqImageNames.add(item.getName())) {
                throw new RuntimeException("Duplicate image name: " + item.getName());
            }
        }
        for (CreateProductOptionImages item : reqOptionImages) {
            if (!reqImageNames.add(item.getImageName())) {
                throw new RuntimeException("Duplicate image name: " + item.getImageName());
            }
        }

        Set<String> setReqMediaImages = new HashSet<>();
        for (MultipartFile item : media) {
            if (!setReqMediaImages.add(item.getOriginalFilename())) {
                throw new RuntimeException("Duplicate image name: " + item.getName());
            }
        }

        if (!reqImageNames.equals(setReqMediaImages)) {
            throw new RuntimeException("Images do not match");
        }

        // insert uploaded images

        // validate attributes
        // rule map
        List<AttributesEntity> categoryAttributes = categoryEntity.getAttributes();
        Map<Long, AttributesRule> ruleMap = new HashMap<>();
        for (AttributesEntity attr : categoryAttributes) {
            AttributesRule rule = new AttributesRule();
            rule.setRequired(attr.getIsRequired());
            rule.setMultipleAllow(attr.getIsMultipleAllow());
            rule.setCustomAllow(attr.getIsCustomAllow());
            rule.setType(attr.getType());
            ruleMap.put(attr.getId(), rule);
        }

        // validate required attributes
        List<CreateProductAttributeDto> reqAttributes = req.getAttributes();
        Set<Long> categoryAttributeIds = categoryAttributes.stream()
                .map(AttributesEntity::getId).collect(Collectors.toSet());
        Set<Long> requiredAttributeIds = ruleMap.entrySet().stream()
                .filter(e -> e.getValue().isRequired())
                .map(Map.Entry::getKey)
                .collect(Collectors.toSet());
        Set<Long> reqAttributeIds = new HashSet<>();
        for (CreateProductAttributeDto attr : reqAttributes) {
            if (!reqAttributeIds.add(attr.getId())) {
                throw new RuntimeException("Duplicate attribute");
            }
        }
        if (!categoryAttributeIds.containsAll(reqAttributeIds)) {
            throw new RuntimeException("Invalid attribute id");
        }
        if (!reqAttributeIds.containsAll(requiredAttributeIds)) {
            throw new RuntimeException("Required attribute not found");
        }
        List<CreateProductAttributeDto> finalAttributes = new ArrayList<>();

        for (CreateProductAttributeDto attr : reqAttributes) {
            AttributesRule rule = ruleMap.get(attr.getId());
            boolean hasValues = attr.getValueIds() != null && !attr.getValueIds().isEmpty();
            boolean hasCustomValues = attr.getCustomValues() != null && !attr.getCustomValues().isEmpty();
            List<Long> valueIds =
                    attr.getValueIds() == null ? List.of() : attr.getValueIds();
            List<String> customValues =
                    attr.getCustomValues() == null ? List.of() : attr.getCustomValues();
            Set<Long> setValueIds = new HashSet<>();
            for (Long id : valueIds) {
                if (!setValueIds.add(id)) {
                    throw new RuntimeException("Duplicate value id " + id);
                }
            }
            Set<String> seenCustomValues = new HashSet<>();
            for (String value : customValues) {
                if (!seenCustomValues.add(value.toLowerCase(Locale.ROOT))) {
                    throw new RuntimeException("Duplicate custom value: " + value);
                }
            }
            AttributeTypesEnums type = rule.getType();
            switch (type) {
                case DATE -> {
                    if (hasValues) {
                        throw new RuntimeException("DATE attribute must not have valueIds");
                    }
                    if (!hasCustomValues) {
                        throw new RuntimeException("DATE attribute must have a custom value");
                    }
                    if (attr.getCustomValues().size() != 1) {
                        throw new RuntimeException("DATE attribute must have exactly one custom value");
                    }
                    try {
                        LocalDate.parse(attr.getCustomValues().getFirst().trim()); // ISO-8601
                    } catch (DateTimeParseException e) {
                        throw new RuntimeException("Invalid DATE format. Expected yyyy-MM-dd");
                    }
                }
                case BOOLEAN -> {
                    if (hasCustomValues) {
                        throw new RuntimeException("BOOLEAN attribute must not have custom values");
                    }
                    if (!hasValues) {
                        throw new RuntimeException("BOOLEAN attribute must have a value");
                    }
                    if (attr.getValueIds().size() != 1) {
                        throw new RuntimeException("BOOLEAN attribute must have exactly one value");
                    }
                }
                case NUMBER -> {
                    if (hasCustomValues) {
                        try {
                            for (String val : customValues) {
                                Double.parseDouble(val);
                            }
                        } catch (NumberFormatException e) {
                            throw new RuntimeException("Invalid number format. Expected a number");
                        }
                    }
                }
            }
            if (!rule.isCustomAllow() && hasCustomValues) {
                throw new RuntimeException("This required attributes don't allow custom value");
            }
            int totalValues = valueIds.size() + customValues.size();
            if (rule.isRequired() && totalValues == 0) {
                throw new RuntimeException("Required attributes must have at least one value");
            }
            if (!rule.isMultipleAllow() && totalValues > 1) {
                throw new RuntimeException("Multiple attributes must have at most one value");
            }

            // TỐI ƯU NOTE: check tối ưu n + 1 query nhé
            Set<Long> attributeValuesEntityIds = attributesRepo.getReferenceById(
                    attr.getId())
                    .getAttributeValues()
                    .stream()
                    .map(AttributeValuesEntity::getId)
                    .collect(Collectors.toSet());
            if (hasValues && !attributeValuesEntityIds.containsAll(setValueIds)) {
                throw new RuntimeException("Value ids not belong to attribute");
            }

            if (hasValues || hasCustomValues) {
                finalAttributes.add(attr);
            }
        }

        // save db finalAttributes
        // tìm hiểu lại jpa, refernece by id, lazy load, rồi cascade. hiểu bản chất
        List<ProductAttributesEntity> listProductAttributeEntity = new ArrayList<>();
        for (CreateProductAttributeDto attr : finalAttributes) {
            AttributesRule rule = ruleMap.get(attr.getId());
            AttributesEntity attributesEntity = attributesRepo.findById(attr.getId()).orElseThrow();
            List<AttributeValuesEntity> listAttributeValuesEntity = new ArrayList<>();
            List<Long> valueIds = attr.getValueIds();
            List<String> customValues = attr.getCustomValues();
            if (valueIds != null && !valueIds.isEmpty()) {
                for (Long id : valueIds) {
                    AttributeValuesEntity valuesEntity = attributeValuesRepo.getReferenceById(id);
                    listAttributeValuesEntity.add(valuesEntity);
                }
            }
            if (customValues != null && !customValues.isEmpty()) {
                AttributeTypesEnums type = rule.getType();
                switch (type) {
                    case DATE -> {
                        AttributeValuesEntity valuesEntity = new AttributeValuesEntity();
                        valuesEntity.setIsCustom(true);
                        valuesEntity.setValueDate(LocalDate.parse(attr.getCustomValues().getFirst().trim()));
                        valuesEntity.setAttributesEntity(attributesEntity);
                        listAttributeValuesEntity.add(valuesEntity);
                    }
                    case TEXT -> {
                        for (String value : customValues) {
                            AttributeValuesEntity valuesEntity = new AttributeValuesEntity();
                            valuesEntity.setIsCustom(true);
                            valuesEntity.setValueText(value);
                            valuesEntity.setAttributesEntity(attributesEntity);
                            listAttributeValuesEntity.add(valuesEntity);
                        }
                    }
                    case NUMBER -> {
                        for (String value : customValues) {
                            AttributeValuesEntity valuesEntity = new AttributeValuesEntity();
                            valuesEntity.setIsCustom(true);
                            valuesEntity.setValueNumber(Double.parseDouble(value));
                            valuesEntity.setAttributesEntity(attributesEntity);
                            listAttributeValuesEntity.add(valuesEntity);
                        }
                    }
                }
            }

            attributesEntity.getAttributeValues().addAll(listAttributeValuesEntity);

            for (AttributeValuesEntity val: listAttributeValuesEntity) {
                System.out.println(val.getValueText());
                ProductAttributesEntity productAttributesEntity = new ProductAttributesEntity();
                productAttributesEntity.setProductEntity(product);
                productAttributesEntity.setAttributesEntity(attributesEntity);
                productAttributesEntity.setAttributeValuesEntity(val);
                if (val.getIsCustom()) {
                    val.getProductAttributes().add(productAttributesEntity);
                }

                listProductAttributeEntity.add(productAttributesEntity);
            }
        }

        product.getProductAttributes().addAll(listProductAttributeEntity);

        // Product tier options
        boolean hasTiers = req.getTiers() != null;
        if(!hasTiers) {
            CreateProductVariationDto reqVariation = validateNoTiers(req);
            VariationEntity variation = new VariationEntity();
            variation.setPrice(reqVariation.getPrice());
            variation.setStock(reqVariation.getStock());
            variation.setProductEntity(product);
            product.getVariations().add(variation);
        } else {
            TierValidationResult tierValidationResult = validateTiers(req);
            Map<String, Set<String>> normalizeTierOptionMap = tierValidationResult.getNormalizedTierOptions();
            List<CreateProductVariationDto> reqVariations = validateVariations(
                    req,
                    normalizeTierOptionMap,
                    tierValidationResult.getCountCartesian()
            );
            // Add tiers + options from tiers request
            for (Map.Entry<String, Set<String>> entry : normalizeTierOptionMap.entrySet()) {
                TierEntity tierEntity = new TierEntity();
                tierEntity.setName(entry.getKey());
                tierEntity.setProductEntity(product);
                product.getTiers().add(tierEntity);
                for (String option : entry.getValue()) {
                    OptionsEntity optionEntity = new OptionsEntity();
                    optionEntity.setName(option);
                    optionEntity.setTierEntity(tierEntity);
                    tierEntity.getOptions().add(optionEntity);
                }
            }
            // Add variations and variation_option for variation_request
            for (CreateProductVariationDto reqVariation : reqVariations) {
                VariationEntity variationEntity = new VariationEntity();
                variationEntity.setPrice(reqVariation.getPrice());
                variationEntity.setStock(reqVariation.getStock());
                variationEntity.setProductEntity(product);
                for (CreateProductRequestOptionCombination optionCombination : reqVariation.getOptionCombination()) {
                    String tierName = optionCombination.getTierName().toLowerCase();
                    String optionName = optionCombination.getOptionName().toLowerCase();
                    List<TierEntity> listTierEntity = product.getTiers();
                    for (TierEntity tierEntity : listTierEntity) {
                        if (tierEntity.getName().equals(tierName)) {
                            List<OptionsEntity> ops = tierEntity.getOptions();
                            for (OptionsEntity optionEntity : ops) {
                                if (optionEntity.getName().equals(optionName)) {
                                    VariationOptionEntity variationOptionEntity = new VariationOptionEntity();
                                    variationOptionEntity.setVariationEntity(variationEntity);
                                    variationOptionEntity.setOptionsEntity(optionEntity);
                                    variationEntity.getVariationOptions().add(variationOptionEntity);
                                }
                            }
                        }
                    }
                }
                product.getVariations().add(variationEntity);
            }
        }

        productRepo.save(product);
    }

    private static CreateProductVariationDto validateNoTiers(CreateProductRequest req) {
        List<CreateProductVariationDto> reqVariations = req.getVariations();
        if (reqVariations.size() != 1) {
            throw new RuntimeException("Invalid variation size");
        }
        return reqVariations.getFirst();
    }

    private static TierValidationResult validateTiers(CreateProductRequest req) {
        List<CreateProductTierDto> reqTiers = req.getTiers();
        Map<String, Set<String>> normalizeTierOptionMap = new HashMap<>();
        int countCartesian = 1;

        Set<String> seenTiers = new HashSet<>();
        for (CreateProductTierDto tier : reqTiers) {
            if(!seenTiers.add(tier.getName().toLowerCase(Locale.ROOT))) {
                throw new RuntimeException("Duplicate tier");
            }
            List<String> options = tier.getOptions();
            Set<String> optionSet  = new HashSet<>();
            for (String option : options) {
                if (!optionSet.add(option.toLowerCase(Locale.ROOT))) {
                    throw new RuntimeException("Duplicate option.");
                }
            }
            countCartesian *= optionSet.size();
            normalizeTierOptionMap.put(tier.getName().toLowerCase(Locale.ROOT), optionSet);
        }
        return new TierValidationResult(normalizeTierOptionMap, countCartesian);
    }

    private static List<CreateProductVariationDto> validateVariations(
            CreateProductRequest req,
            Map<String, Set<String>> normalizeTierOptionMap,
            int countCartesian
    ) {
        List<CreateProductVariationDto> reqVariations = req.getVariations();
        // Check count cartesian build từ tiers request có match với size của req variation k
        if (reqVariations.size() != countCartesian) {
            throw new RuntimeException("Variations count does not match cartesian");
        }
        Set<Set<String>> seenOptionCombinations = new HashSet<>();
        for (CreateProductVariationDto reqVariation : reqVariations) {
            List<CreateProductRequestOptionCombination> comb = reqVariation.getOptionCombination();
            // check xem size của list option combination có trùng với size của list tiers request k
            if (comb == null || comb.isEmpty()) {
                throw new RuntimeException("Empty variation combination");
            }
            if (comb.size() != normalizeTierOptionMap.size()) {
                throw new RuntimeException("Invalid variation size");
            }
            Set<String> seenTierName = new HashSet<>();
            Set<String> seenOptionCombinationName = new HashSet<>();
            for (CreateProductRequestOptionCombination item : comb) {
                String normalizeTierName = item.getTierName().toLowerCase(Locale.ROOT);
                String normalizeOptionName = item.getOptionName().toLowerCase(Locale.ROOT);
                // check xem tier name trong option combination có trùng k
                if (!seenTierName.add(normalizeTierName)) {
                    throw new RuntimeException("Duplicate tier name");
                }
                // check xem tier name trong option combination có tồn tại trong tiers request k
                if (normalizeTierOptionMap.get(normalizeTierName) == null) {
                    throw new RuntimeException("Invalid tier");
                }
                // check xem optionName có thuộc options trong tier options của tiers request k
                if (!normalizeTierOptionMap.get(normalizeTierName).contains(normalizeOptionName)) {
                    throw new RuntimeException("Invalid variation option");
                }
                String key = normalizeTierName + ":" + normalizeOptionName;
                seenOptionCombinationName.add(key);

            }
            // check xem option combination của mỗi variation có bị trùng k
            if (!seenOptionCombinations.add(seenOptionCombinationName)) {
                throw new RuntimeException("Duplicate variation option combination");
            }
        }
        return reqVariations;
    }
}
</file>

<file path="src/main/java/com/chobbi/server/catalog/services/CategoryServices.java">
package com.chobbi.server.catalog.services;

import com.chobbi.server.catalog.entity.CategoryEntity;

public interface CategoryServices {
    CategoryEntity getLeafCategoryOrThrow(Long categoryId);
}
</file>

<file path="src/main/java/com/chobbi/server/catalog/services/ProductServices.java">
package com.chobbi.server.catalog.services;

import com.chobbi.server.catalog.dto.CreateProductRequest;
import org.springframework.web.multipart.MultipartFile;

public interface ProductServices {
    void createProduct(CreateProductRequest productRequest, MultipartFile[] media);
}
</file>

<file path="src/main/java/com/chobbi/server/catalog/cart.json">

</file>

<file path="src/main/java/com/chobbi/server/catalog/product-detail-buyer.json">
{
  "id": 1,
  "name": "name_9a67e504330d",
  "img_thumbnail": "/images/.jpg",
  "img_list": [
    {
      "url": "/images/.jpg",
      "sort_order": 1
    },
    {
      "url": "/images/.jpg",
      "sort_order": 2
    }
  ],
  "description": "hello description",
  "attributes": [
    {
      "name": "Thương hiệu",
      "value": "NO BRAND"
    },
    {
      "name": "Xuất xú",
      "value": "China"
    }
  ],
  "tiers": [
    {
      "id": 0,
      "name": "name_b94af93c2224",
      "options": [
        {
          "id": 0,
          "name": "name_7bd64675c658"
        },
        {
          "id": 1,
          "name": "name_7bd64675c658"
        }
      ]
    }
  ],
  "variations": [
    {
      "id": 0,
      "sku": "sku_dde896825a7a",
      "option_indices": [
        0
      ],
      "price": 0.00,
      "stock": 0
    }
  ],
  "categories": [
    {
      "id": 0,
      "name": "name_c64ae4825c73"
    }
  ]
}
</file>

<file path="src/main/java/com/chobbi/server/catalog/product-update-seller.json">
{
  "id": 1,
  "name": "name_9a67e504330d",
  "img_thumbnail": "/images/.jpg",
  "img_list": [
    {
      "url": "/images/.jpg",
      "sort_order": 1
    },
    {
      "url": "/images/.jpg",
      "sort_order": 2
    }
  ],
  "description": "hello description",
  "attributes": [
    {
      "name": "Thương hiệu",
      "value": "NO BRAND"
    },
    {
      "name": "Xuất xú",
      "value": "China"
    }
  ],
  "tiers": [
    {
      "id": 0,
      "name": "name_b94af93c2224",
      "options": [
        {
          "id": 0,
          "name": "name_7bd64675c658"
        },
        {
          "id": 1,
          "name": "name_7bd64675c658"
        }
      ]
    }
  ],
  "variations": [
    {
      "id": 0,
      "sku": "sku_dde896825a7a",
      "option_indices": [
        0
      ],
      "price": 0.00,
      "stock": 0
    }
  ],
  "categories": [
    {
      "id": 0,
      "name": "name_c64ae4825c73"
    }
  ]
}
</file>

<file path="src/main/java/com/chobbi/server/common/BaseEntity.java">
package com.chobbi.server.common;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.time.LocalDateTime;

@Getter
@Setter
@MappedSuperclass
public abstract class BaseEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @CreationTimestamp
    @Column(name = "created_at", updatable = false, nullable = false)
    private LocalDateTime createdAt;

    @UpdateTimestamp
    @Column(name = "updated_at", nullable = false)
    private LocalDateTime updatedAt;

    @Column(name = "deleted_at")
    private LocalDateTime deletedAt;

    public void softDelete() {
        this.deletedAt = LocalDateTime.now();
    }

    public boolean isDeleted() {
        return this.deletedAt != null;
    }
}
</file>

<file path="src/main/java/com/chobbi/server/config/SecurityConfig.java">
package com.chobbi.server.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
public class SecurityConfig {

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity httpSecurity) throws Exception {
        return httpSecurity
                .csrf(csrf -> csrf.disable())
                .authorizeHttpRequests(req -> {
                    req.anyRequest().permitAll();
                })
                .build();
    }
}
</file>

<file path="src/main/java/com/chobbi/server/controller/AuthenticationController.java">
package com.chobbi.server.controller;

import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequiredArgsConstructor
@RequestMapping("/auth")
public class AuthenticationController {
    @PostMapping("/register")
    public ResponseEntity<?> register() {

        return ResponseEntity.ok("Register endpoint");
    }
}
</file>

<file path="src/main/java/com/chobbi/server/controller/CheckoutController.java">
package com.chobbi.server.controller;

import lombok.RequiredArgsConstructor;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/checkout")
@RequiredArgsConstructor
public class CheckoutController {
    @GetMapping
    public String checkout() {
        return "Checkout endpoint";
    }
}
</file>

<file path="src/main/java/com/chobbi/server/dto/cart/CartAddResponseDto.java">
package com.chobbi.server.dto.cart;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class CartAddResponseDto {
    private Long shopId;
    private Long productId;
    private BigDecimal priceUnit;
}
</file>

<file path="src/main/java/com/chobbi/server/dto/cart/CartProductDto.java">
package com.chobbi.server.dto.cart;

import com.chobbi.server.dto.TierDto;
import com.chobbi.server.dto.VariationDto;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.List;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class CartProductDto {
    private Long productId;
    private String productName;
    private Integer quantity;
    private Long selected_variation_id;
    private BigDecimal price_unit;
    private List<TierDto> tiers = new ArrayList<>();
    private List<VariationDto> variations = new ArrayList<>();
}
</file>

<file path="src/main/java/com/chobbi/server/dto/cart/CartResponseDto.java">
package com.chobbi.server.dto.cart;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class CartResponseDto {
    private Long accountId;
    private List<CartShopDto> shops;
}
</file>

<file path="src/main/java/com/chobbi/server/dto/cart/CartShopDto.java">
package com.chobbi.server.dto.cart;

import com.chobbi.server.dto.TierDto;
import com.chobbi.server.dto.VariationDto;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.ArrayList;
import java.util.List;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class CartShopDto {
    private Long shopId;
    private String shopName;
    private List<CartProductDto> product;
}
</file>

<file path="src/main/java/com/chobbi/server/dto/CategoryDto.java">
package com.chobbi.server.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class CategoryDto {
    private Long id;
    private String name;
}
</file>

<file path="src/main/java/com/chobbi/server/dto/OptionDto.java">
package com.chobbi.server.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class OptionDto {
    private Long id;
    private String name;
}
</file>

<file path="src/main/java/com/chobbi/server/dto/OptionRequestDto.java">
package com.chobbi.server.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class OptionRequestDto {
    private Long id;
    private String name;
}
</file>

<file path="src/main/java/com/chobbi/server/dto/ProductVariationDto.java">
package com.chobbi.server.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class ProductVariationDto {
    private Long productId;
    private Long productName;
}
</file>

<file path="src/main/java/com/chobbi/server/dto/TierDto.java">
package com.chobbi.server.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.ArrayList;
import java.util.List;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class TierDto {
    private Long id;
    private String name;
    private List<OptionDto> options = new ArrayList<>();
}
</file>

<file path="src/main/java/com/chobbi/server/dto/TierRequestDto.java">
package com.chobbi.server.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.ArrayList;
import java.util.List;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class TierRequestDto {
    private Long id;
    private String name;
    private List<OptionRequestDto> options = new ArrayList<>();
}
</file>

<file path="src/main/java/com/chobbi/server/dto/VariationDto.java">
package com.chobbi.server.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.List;

//      "id": 1001,
//              "sku": "TS-RED-M",
//              "option_value_ids": [
//              101,
//              201
//              ],
//              "price": 150000,
//              "stock": 10
@Data
@AllArgsConstructor
@NoArgsConstructor
public class VariationDto {
    private Long id;
    private String sku;
    private List<Integer> option_indices = new ArrayList<>();
    private BigDecimal price;
    private Long stock;
}
</file>

<file path="src/main/java/com/chobbi/server/dto/VariationQuantityDto.java">
package com.chobbi.server.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class VariationQuantityDto {
    private Long variationId;
    private Long variationName;
    private BigDecimal price;
    private BigDecimal priceDiscount;
    private Integer stock;
    private Integer quantity;
}
</file>

<file path="src/main/java/com/chobbi/server/dto/VariationRequestDto.java">
package com.chobbi.server.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.List;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class VariationRequestDto {
    private Long id;
    private String name;
    private String sku;
    private BigDecimal price;
    private Long stock;
    private List<Integer> option_indices = new ArrayList<>();
}
</file>

<file path="src/main/java/com/chobbi/server/entity/AccountRolesEntity.java">
package com.chobbi.server.entity;

import jakarta.persistence.*;
import lombok.Data;

@Data
@Entity(name = "account_roles")
public class AccountRolesEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne
    @JoinColumn(name = "account_id")
    private AccountEntity accountEntity;

    @ManyToOne
    @JoinColumn(name = "roles_id")
    private RolesEntity rolesEntity;
}
</file>

<file path="src/main/java/com/chobbi/server/enums/ProductDtofieldEnums.java">
package com.chobbi.server.enums;

public enum ProductDtofieldEnums {
    OPTIONS,
    VARIANTS,
    CATEGORIES
}
</file>

<file path="src/main/java/com/chobbi/server/exception/BusinessException.java">
package com.chobbi.server.exception;

import org.springframework.http.HttpStatus;

public class BusinessException extends RuntimeException {
    private final HttpStatus status;

    public BusinessException(String message, HttpStatus status) {
        super(message);
        this.status = status;
    }

    public HttpStatus getStatus() {
        return status;
    }
}
</file>

<file path="src/main/java/com/chobbi/server/exception/GlobalExceptionHandler.java">
package com.chobbi.server.exception;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;

@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(BusinessException.class)
    public ResponseEntity<Map<String, Object>> handleBusinessException(BusinessException ex) {
        Map<String, Object> body = new HashMap<>();
        body.put("timestamp", LocalDateTime.now());
        body.put("status", ex.getStatus().value());
        body.put("error", ex.getStatus().getReasonPhrase());
        body.put("message", ex.getMessage());

        return new ResponseEntity<>(body, ex.getStatus());
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<Map<String, Object>> handleGeneralException(Exception ex) {
        Map<String, Object> body = new HashMap<>();
        body.put("timestamp", LocalDateTime.now());
        body.put("status", HttpStatus.INTERNAL_SERVER_ERROR.value());
        body.put("error", "Internal Server Error");
        body.put("message", ex.getMessage());

        return new ResponseEntity<>(body, HttpStatus.INTERNAL_SERVER_ERROR);
    }
}
</file>

<file path="src/main/java/com/chobbi/server/files/controller/FilesController.java">
package com.chobbi.server.storage.controller;

import com.chobbi.server.storage.message.ResponseMessage;
import com.chobbi.server.storage.services.FilesStorageService;
import org.apache.tomcat.jni.FileInfo;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.io.Resource;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;
import org.springframework.web.servlet.mvc.method.annotation.MvcUriComponentsBuilder;

import java.util.List;
import java.util.stream.Collectors;

@Controller
@CrossOrigin("http://localhost:9090")
public class FilesController {

    @Autowired
    FilesStorageService storageService;

    @PostMapping("/upload")
    public ResponseEntity<ResponseMessage> uploadFile(@RequestParam("file") MultipartFile file) {
        String message = "";
        try {
            storageService.save(file);

            message = "Uploaded the file successfully: " + file.getOriginalFilename();
            return ResponseEntity.status(HttpStatus.OK).body(new ResponseMessage(message));
        } catch (Exception e) {
            message = "Could not upload the file: " + file.getOriginalFilename() + ". Error: " + e.getMessage();
            return ResponseEntity.status(HttpStatus.EXPECTATION_FAILED).body(new ResponseMessage(message));
        }
    }

//    @GetMapping("/files")
//    public ResponseEntity<List<FileInfo>> getListFiles() {
//        List<FileInfo> fileInfos = storageService.loadAll().map(path -> {
//            String filename = path.getFileName().toString();
//            String url = MvcUriComponentsBuilder
//                    .fromMethodName(FilesController.class, "getFile", path.getFileName().toString()).build().toString();
//
//            return new FileInfo(filename, url);
//        }).collect(Collectors.toList());
//
//        return ResponseEntity.status(HttpStatus.OK).body(fileInfos);
//    }

    @GetMapping("/files/{filename:.+}")
    public ResponseEntity<Resource> getFile(@PathVariable String filename) {
        Resource file = storageService.load(filename);
        return ResponseEntity.ok()
                .header(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=\"" + file.getFilename() + "\"").body(file);
    }

    @DeleteMapping("/files/{filename:.+}")
    public ResponseEntity<ResponseMessage> deleteFile(@PathVariable String filename) {
        String message = "";

        try {
            boolean existed = storageService.delete(filename);

            if (existed) {
                message = "Delete the file successfully: " + filename;
                return ResponseEntity.status(HttpStatus.OK).body(new ResponseMessage(message));
            }

            message = "The file does not exist!";
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(new ResponseMessage(message));
        } catch (Exception e) {
            message = "Could not delete the file: " + filename + ". Error: " + e.getMessage();
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(new ResponseMessage(message));
        }
    }
}
</file>

<file path="src/main/java/com/chobbi/server/files/exception/FileUploadExceptionAdvice.java">
package com.chobbi.server.storage.exception;

import com.chobbi.server.storage.message.ResponseMessage;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.multipart.MaxUploadSizeExceededException;
import org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler;

@ControllerAdvice
public class FileUploadExceptionAdvice extends ResponseEntityExceptionHandler {

    @ExceptionHandler(MaxUploadSizeExceededException.class)
    public ResponseEntity<ResponseMessage> handleMaxSizeException(MaxUploadSizeExceededException exc) {
        return ResponseEntity.status(HttpStatus.EXPECTATION_FAILED).body(new ResponseMessage("File too large!"));
    }
}
</file>

<file path="src/main/java/com/chobbi/server/files/message/ResponseMessage.java">
    package com.chobbi.server.storage.message;

    import lombok.Getter;
    import lombok.Setter;

    @Getter
    @Setter
    public class ResponseMessage {
    private String message;

    public ResponseMessage(String message) {
    this.message = message;
    }
    }
</file>

<file path="src/main/java/com/chobbi/server/files/services/impl/FilesStorageServiceImpl.java">
package com.chobbi.server.storage.services.impl;

import com.chobbi.server.storage.FolderTypeEnum;
import com.chobbi.server.storage.services.FilesStorageService;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.core.io.Resource;
import org.springframework.core.io.UrlResource;
import org.springframework.stereotype.Service;
import org.springframework.util.FileSystemUtils;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.net.MalformedURLException;
import java.nio.file.FileAlreadyExistsException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.LocalDate;
import java.util.stream.Stream;

@Service
public class FilesStorageServiceImpl implements FilesStorageService {

    @Value("${file.root-path}")
    private String rootPath;
    // create folder path: ex 2026/01/19/file.webp
    // gen uuid name for each image
    // transform to webp
    // save file into folder

    public String storeFile(MultipartFile file, FolderTypeEnum folderType) {
        try {
            String folderName = folderType.getFolderName();
            LocalDate now = LocalDate.now();
            String relativePath = String.format("%s/%d/%02d/%02d",
                    folderType,
                    now.getYear(), now.getMonthValue(), now.getDayOfMonth());

            Path targetLocation = Paths.get(rootPath).resolve(relativePath);

            Files.createDirectories(targetLocation);

            // 3. Lưu file (FE đã thêm timestamp nên ko sợ trùng)
            String fileName = file.getOriginalFilename();
            Path filePath = targetLocation.resolve(fileName);
            Files.copy(file.getInputStream(), filePath, StandardCopyOption.REPLACE_EXISTING);

            return relativePath + "/" + fileName;

        } catch (IOException ex) {
            throw new RuntimeException("Lỗi lưu file " + folderType, ex);
        }
    }

    @Override
    public void save(MultipartFile file) {
        try {
            Files.copy(file.getInputStream(), this.root.resolve(file.getOriginalFilename()));
        } catch (Exception e) {
            if (e instanceof FileAlreadyExistsException) {
                throw new RuntimeException("A file of that name already exists.");
            }

            throw new RuntimeException(e.getMessage());
        }
    }

    @Override
    public Resource load(String filename) {
        try {
            Path file = root.resolve(filename);
            Resource resource = new UrlResource(file.toUri());

            if (resource.exists() || resource.isReadable()) {
                return resource;
            } else {
                throw new RuntimeException("Could not read the file!");
            }
        } catch (MalformedURLException e) {
            throw new RuntimeException("Error: " + e.getMessage());
        }
    }

    @Override
    public boolean delete(String filename) {
        try {
            Path file = root.resolve(filename);
            return Files.deleteIfExists(file);
        } catch (IOException e) {
            throw new RuntimeException("Error: " + e.getMessage());
        }
    }

    @Override
    public void deleteAll() {
        FileSystemUtils.deleteRecursively(root.toFile());
    }

    @Override
    public Stream<Path> loadAll() {
        try {
            return Files.walk(this.root, 1).filter(path -> !path.equals(this.root)).map(this.root::relativize);
        } catch (IOException e) {
            throw new RuntimeException("Could not load the files!");
        }
    }

}
</file>

<file path="src/main/java/com/chobbi/server/files/services/FilesStorageService.java">
package com.chobbi.server.storage.services;

import org.springframework.core.io.Resource;
import org.springframework.web.multipart.MultipartFile;

import java.nio.file.Path;
import java.util.stream.Stream;

public interface FilesStorageService {
    public void init();

    public void save(MultipartFile file);

    public Resource load(String filename);

    public boolean delete(String filename);

    public void deleteAll();

    public Stream<Path> loadAll();
}
</file>

<file path="src/main/java/com/chobbi/server/repo/AccountRepo.java">
package com.chobbi.server.repo;

import com.chobbi.server.entity.AccountEntity;
import org.springframework.data.jpa.repository.JpaRepository;

public interface AccountRepo extends JpaRepository<AccountEntity, Long> {
}
</file>

<file path="src/main/java/com/chobbi/server/repo/AttributesRepo.java">
package com.chobbi.server.repo;

import com.chobbi.server.catalog.entity.AttributesEntity;
import org.springframework.data.jpa.repository.JpaRepository;

public interface AttributesRepo extends JpaRepository<AttributesEntity, Long> {
}
</file>

<file path="src/main/java/com/chobbi/server/repo/AttributeValuesRepo.java">
package com.chobbi.server.repo;

import com.chobbi.server.catalog.entity.AttributeValuesEntity;
import org.springframework.data.jpa.repository.JpaRepository;

public interface AttributeValuesRepo extends JpaRepository<AttributeValuesEntity, Long> {
}
</file>

<file path="src/main/java/com/chobbi/server/repo/CartRepo.java">
package com.chobbi.server.repo;

import com.chobbi.server.entity.CartEntity;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;

public interface CartRepo extends JpaRepository<CartEntity, Long> {
    Optional<CartEntity> findByAccountEntityId(Long accountId);
}
</file>

<file path="src/main/java/com/chobbi/server/ServerApplication.java">
package com.chobbi.server;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class ServerApplication {

	public static void main(String[] args) {
		SpringApplication.run(ServerApplication.class, args);
	}

}
</file>

<file path="src/test/java/com/chobbi/server/ServerApplicationTests.java">
package com.chobbi.server;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class ServerApplicationTests {

	@Test
	void contextLoads() {
	}

}
</file>

<file path=".gitattributes">
/mvnw text eol=lf
*.cmd text eol=crlf
</file>

<file path=".gitignore">
HELP.md
target/
.mvn/wrapper/maven-wrapper.jar
!**/src/main/**/target/
!**/src/test/**/target/

### STS ###
.apt_generated
.classpath
.factorypath
.project
.settings
.springBeans
.sts4-cache

### IntelliJ IDEA ###
.idea
*.iws
*.iml
*.ipr

### NetBeans ###
/nbproject/private/
/nbbuild/
/dist/
/nbdist/
/.nb-gradle/
build/
!**/src/main/**/build/
!**/src/test/**/build/

### VS Code ###
.vscode/
</file>

<file path="mvnw">
#!/bin/sh
# ----------------------------------------------------------------------------
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
# ----------------------------------------------------------------------------

# ----------------------------------------------------------------------------
# Apache Maven Wrapper startup batch script, version 3.3.4
#
# Optional ENV vars
# -----------------
#   JAVA_HOME - location of a JDK home dir, required when download maven via java source
#   MVNW_REPOURL - repo url base for downloading maven distribution
#   MVNW_USERNAME/MVNW_PASSWORD - user and password for downloading maven
#   MVNW_VERBOSE - true: enable verbose log; debug: trace the mvnw script; others: silence the output
# ----------------------------------------------------------------------------

set -euf
[ "${MVNW_VERBOSE-}" != debug ] || set -x

# OS specific support.
native_path() { printf %s\\n "$1"; }
case "$(uname)" in
CYGWIN* | MINGW*)
  [ -z "${JAVA_HOME-}" ] || JAVA_HOME="$(cygpath --unix "$JAVA_HOME")"
  native_path() { cygpath --path --windows "$1"; }
  ;;
esac

# set JAVACMD and JAVACCMD
set_java_home() {
  # For Cygwin and MinGW, ensure paths are in Unix format before anything is touched
  if [ -n "${JAVA_HOME-}" ]; then
    if [ -x "$JAVA_HOME/jre/sh/java" ]; then
      # IBM's JDK on AIX uses strange locations for the executables
      JAVACMD="$JAVA_HOME/jre/sh/java"
      JAVACCMD="$JAVA_HOME/jre/sh/javac"
    else
      JAVACMD="$JAVA_HOME/bin/java"
      JAVACCMD="$JAVA_HOME/bin/javac"

      if [ ! -x "$JAVACMD" ] || [ ! -x "$JAVACCMD" ]; then
        echo "The JAVA_HOME environment variable is not defined correctly, so mvnw cannot run." >&2
        echo "JAVA_HOME is set to \"$JAVA_HOME\", but \"\$JAVA_HOME/bin/java\" or \"\$JAVA_HOME/bin/javac\" does not exist." >&2
        return 1
      fi
    fi
  else
    JAVACMD="$(
      'set' +e
      'unset' -f command 2>/dev/null
      'command' -v java
    )" || :
    JAVACCMD="$(
      'set' +e
      'unset' -f command 2>/dev/null
      'command' -v javac
    )" || :

    if [ ! -x "${JAVACMD-}" ] || [ ! -x "${JAVACCMD-}" ]; then
      echo "The java/javac command does not exist in PATH nor is JAVA_HOME set, so mvnw cannot run." >&2
      return 1
    fi
  fi
}

# hash string like Java String::hashCode
hash_string() {
  str="${1:-}" h=0
  while [ -n "$str" ]; do
    char="${str%"${str#?}"}"
    h=$(((h * 31 + $(LC_CTYPE=C printf %d "'$char")) % 4294967296))
    str="${str#?}"
  done
  printf %x\\n $h
}

verbose() { :; }
[ "${MVNW_VERBOSE-}" != true ] || verbose() { printf %s\\n "${1-}"; }

die() {
  printf %s\\n "$1" >&2
  exit 1
}

trim() {
  # MWRAPPER-139:
  #   Trims trailing and leading whitespace, carriage returns, tabs, and linefeeds.
  #   Needed for removing poorly interpreted newline sequences when running in more
  #   exotic environments such as mingw bash on Windows.
  printf "%s" "${1}" | tr -d '[:space:]'
}

scriptDir="$(dirname "$0")"
scriptName="$(basename "$0")"

# parse distributionUrl and optional distributionSha256Sum, requires .mvn/wrapper/maven-wrapper.properties
while IFS="=" read -r key value; do
  case "${key-}" in
  distributionUrl) distributionUrl=$(trim "${value-}") ;;
  distributionSha256Sum) distributionSha256Sum=$(trim "${value-}") ;;
  esac
done <"$scriptDir/.mvn/wrapper/maven-wrapper.properties"
[ -n "${distributionUrl-}" ] || die "cannot read distributionUrl property in $scriptDir/.mvn/wrapper/maven-wrapper.properties"

case "${distributionUrl##*/}" in
maven-mvnd-*bin.*)
  MVN_CMD=mvnd.sh _MVNW_REPO_PATTERN=/maven/mvnd/
  case "${PROCESSOR_ARCHITECTURE-}${PROCESSOR_ARCHITEW6432-}:$(uname -a)" in
  *AMD64:CYGWIN* | *AMD64:MINGW*) distributionPlatform=windows-amd64 ;;
  :Darwin*x86_64) distributionPlatform=darwin-amd64 ;;
  :Darwin*arm64) distributionPlatform=darwin-aarch64 ;;
  :Linux*x86_64*) distributionPlatform=linux-amd64 ;;
  *)
    echo "Cannot detect native platform for mvnd on $(uname)-$(uname -m), use pure java version" >&2
    distributionPlatform=linux-amd64
    ;;
  esac
  distributionUrl="${distributionUrl%-bin.*}-$distributionPlatform.zip"
  ;;
maven-mvnd-*) MVN_CMD=mvnd.sh _MVNW_REPO_PATTERN=/maven/mvnd/ ;;
*) MVN_CMD="mvn${scriptName#mvnw}" _MVNW_REPO_PATTERN=/org/apache/maven/ ;;
esac

# apply MVNW_REPOURL and calculate MAVEN_HOME
# maven home pattern: ~/.m2/wrapper/dists/{apache-maven-<version>,maven-mvnd-<version>-<platform>}/<hash>
[ -z "${MVNW_REPOURL-}" ] || distributionUrl="$MVNW_REPOURL$_MVNW_REPO_PATTERN${distributionUrl#*"$_MVNW_REPO_PATTERN"}"
distributionUrlName="${distributionUrl##*/}"
distributionUrlNameMain="${distributionUrlName%.*}"
distributionUrlNameMain="${distributionUrlNameMain%-bin}"
MAVEN_USER_HOME="${MAVEN_USER_HOME:-${HOME}/.m2}"
MAVEN_HOME="${MAVEN_USER_HOME}/wrapper/dists/${distributionUrlNameMain-}/$(hash_string "$distributionUrl")"

exec_maven() {
  unset MVNW_VERBOSE MVNW_USERNAME MVNW_PASSWORD MVNW_REPOURL || :
  exec "$MAVEN_HOME/bin/$MVN_CMD" "$@" || die "cannot exec $MAVEN_HOME/bin/$MVN_CMD"
}

if [ -d "$MAVEN_HOME" ]; then
  verbose "found existing MAVEN_HOME at $MAVEN_HOME"
  exec_maven "$@"
fi

case "${distributionUrl-}" in
*?-bin.zip | *?maven-mvnd-?*-?*.zip) ;;
*) die "distributionUrl is not valid, must match *-bin.zip or maven-mvnd-*.zip, but found '${distributionUrl-}'" ;;
esac

# prepare tmp dir
if TMP_DOWNLOAD_DIR="$(mktemp -d)" && [ -d "$TMP_DOWNLOAD_DIR" ]; then
  clean() { rm -rf -- "$TMP_DOWNLOAD_DIR"; }
  trap clean HUP INT TERM EXIT
else
  die "cannot create temp dir"
fi

mkdir -p -- "${MAVEN_HOME%/*}"

# Download and Install Apache Maven
verbose "Couldn't find MAVEN_HOME, downloading and installing it ..."
verbose "Downloading from: $distributionUrl"
verbose "Downloading to: $TMP_DOWNLOAD_DIR/$distributionUrlName"

# select .zip or .tar.gz
if ! command -v unzip >/dev/null; then
  distributionUrl="${distributionUrl%.zip}.tar.gz"
  distributionUrlName="${distributionUrl##*/}"
fi

# verbose opt
__MVNW_QUIET_WGET=--quiet __MVNW_QUIET_CURL=--silent __MVNW_QUIET_UNZIP=-q __MVNW_QUIET_TAR=''
[ "${MVNW_VERBOSE-}" != true ] || __MVNW_QUIET_WGET='' __MVNW_QUIET_CURL='' __MVNW_QUIET_UNZIP='' __MVNW_QUIET_TAR=v

# normalize http auth
case "${MVNW_PASSWORD:+has-password}" in
'') MVNW_USERNAME='' MVNW_PASSWORD='' ;;
has-password) [ -n "${MVNW_USERNAME-}" ] || MVNW_USERNAME='' MVNW_PASSWORD='' ;;
esac

if [ -z "${MVNW_USERNAME-}" ] && command -v wget >/dev/null; then
  verbose "Found wget ... using wget"
  wget ${__MVNW_QUIET_WGET:+"$__MVNW_QUIET_WGET"} "$distributionUrl" -O "$TMP_DOWNLOAD_DIR/$distributionUrlName" || die "wget: Failed to fetch $distributionUrl"
elif [ -z "${MVNW_USERNAME-}" ] && command -v curl >/dev/null; then
  verbose "Found curl ... using curl"
  curl ${__MVNW_QUIET_CURL:+"$__MVNW_QUIET_CURL"} -f -L -o "$TMP_DOWNLOAD_DIR/$distributionUrlName" "$distributionUrl" || die "curl: Failed to fetch $distributionUrl"
elif set_java_home; then
  verbose "Falling back to use Java to download"
  javaSource="$TMP_DOWNLOAD_DIR/Downloader.java"
  targetZip="$TMP_DOWNLOAD_DIR/$distributionUrlName"
  cat >"$javaSource" <<-END
	public class Downloader extends java.net.Authenticator
	{
	  protected java.net.PasswordAuthentication getPasswordAuthentication()
	  {
	    return new java.net.PasswordAuthentication( System.getenv( "MVNW_USERNAME" ), System.getenv( "MVNW_PASSWORD" ).toCharArray() );
	  }
	  public static void main( String[] args ) throws Exception
	  {
	    setDefault( new Downloader() );
	    java.nio.file.Files.copy( java.net.URI.create( args[0] ).toURL().openStream(), java.nio.file.Paths.get( args[1] ).toAbsolutePath().normalize() );
	  }
	}
	END
  # For Cygwin/MinGW, switch paths to Windows format before running javac and java
  verbose " - Compiling Downloader.java ..."
  "$(native_path "$JAVACCMD")" "$(native_path "$javaSource")" || die "Failed to compile Downloader.java"
  verbose " - Running Downloader.java ..."
  "$(native_path "$JAVACMD")" -cp "$(native_path "$TMP_DOWNLOAD_DIR")" Downloader "$distributionUrl" "$(native_path "$targetZip")"
fi

# If specified, validate the SHA-256 sum of the Maven distribution zip file
if [ -n "${distributionSha256Sum-}" ]; then
  distributionSha256Result=false
  if [ "$MVN_CMD" = mvnd.sh ]; then
    echo "Checksum validation is not supported for maven-mvnd." >&2
    echo "Please disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties." >&2
    exit 1
  elif command -v sha256sum >/dev/null; then
    if echo "$distributionSha256Sum  $TMP_DOWNLOAD_DIR/$distributionUrlName" | sha256sum -c - >/dev/null 2>&1; then
      distributionSha256Result=true
    fi
  elif command -v shasum >/dev/null; then
    if echo "$distributionSha256Sum  $TMP_DOWNLOAD_DIR/$distributionUrlName" | shasum -a 256 -c >/dev/null 2>&1; then
      distributionSha256Result=true
    fi
  else
    echo "Checksum validation was requested but neither 'sha256sum' or 'shasum' are available." >&2
    echo "Please install either command, or disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties." >&2
    exit 1
  fi
  if [ $distributionSha256Result = false ]; then
    echo "Error: Failed to validate Maven distribution SHA-256, your Maven distribution might be compromised." >&2
    echo "If you updated your Maven version, you need to update the specified distributionSha256Sum property." >&2
    exit 1
  fi
fi

# unzip and move
if command -v unzip >/dev/null; then
  unzip ${__MVNW_QUIET_UNZIP:+"$__MVNW_QUIET_UNZIP"} "$TMP_DOWNLOAD_DIR/$distributionUrlName" -d "$TMP_DOWNLOAD_DIR" || die "failed to unzip"
else
  tar xzf${__MVNW_QUIET_TAR:+"$__MVNW_QUIET_TAR"} "$TMP_DOWNLOAD_DIR/$distributionUrlName" -C "$TMP_DOWNLOAD_DIR" || die "failed to untar"
fi

# Find the actual extracted directory name (handles snapshots where filename != directory name)
actualDistributionDir=""

# First try the expected directory name (for regular distributions)
if [ -d "$TMP_DOWNLOAD_DIR/$distributionUrlNameMain" ]; then
  if [ -f "$TMP_DOWNLOAD_DIR/$distributionUrlNameMain/bin/$MVN_CMD" ]; then
    actualDistributionDir="$distributionUrlNameMain"
  fi
fi

# If not found, search for any directory with the Maven executable (for snapshots)
if [ -z "$actualDistributionDir" ]; then
  # enable globbing to iterate over items
  set +f
  for dir in "$TMP_DOWNLOAD_DIR"/*; do
    if [ -d "$dir" ]; then
      if [ -f "$dir/bin/$MVN_CMD" ]; then
        actualDistributionDir="$(basename "$dir")"
        break
      fi
    fi
  done
  set -f
fi

if [ -z "$actualDistributionDir" ]; then
  verbose "Contents of $TMP_DOWNLOAD_DIR:"
  verbose "$(ls -la "$TMP_DOWNLOAD_DIR")"
  die "Could not find Maven distribution directory in extracted archive"
fi

verbose "Found extracted Maven distribution directory: $actualDistributionDir"
printf %s\\n "$distributionUrl" >"$TMP_DOWNLOAD_DIR/$actualDistributionDir/mvnw.url"
mv -- "$TMP_DOWNLOAD_DIR/$actualDistributionDir" "$MAVEN_HOME" || [ -d "$MAVEN_HOME" ] || die "fail to move MAVEN_HOME"

clean || :
exec_maven "$@"
</file>

<file path="mvnw.cmd">
<# : batch portion
@REM ----------------------------------------------------------------------------
@REM Licensed to the Apache Software Foundation (ASF) under one
@REM or more contributor license agreements.  See the NOTICE file
@REM distributed with this work for additional information
@REM regarding copyright ownership.  The ASF licenses this file
@REM to you under the Apache License, Version 2.0 (the
@REM "License"); you may not use this file except in compliance
@REM with the License.  You may obtain a copy of the License at
@REM
@REM    http://www.apache.org/licenses/LICENSE-2.0
@REM
@REM Unless required by applicable law or agreed to in writing,
@REM software distributed under the License is distributed on an
@REM "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
@REM KIND, either express or implied.  See the License for the
@REM specific language governing permissions and limitations
@REM under the License.
@REM ----------------------------------------------------------------------------

@REM ----------------------------------------------------------------------------
@REM Apache Maven Wrapper startup batch script, version 3.3.4
@REM
@REM Optional ENV vars
@REM   MVNW_REPOURL - repo url base for downloading maven distribution
@REM   MVNW_USERNAME/MVNW_PASSWORD - user and password for downloading maven
@REM   MVNW_VERBOSE - true: enable verbose log; others: silence the output
@REM ----------------------------------------------------------------------------

@IF "%__MVNW_ARG0_NAME__%"=="" (SET __MVNW_ARG0_NAME__=%~nx0)
@SET __MVNW_CMD__=
@SET __MVNW_ERROR__=
@SET __MVNW_PSMODULEP_SAVE=%PSModulePath%
@SET PSModulePath=
@FOR /F "usebackq tokens=1* delims==" %%A IN (`powershell -noprofile "& {$scriptDir='%~dp0'; $script='%__MVNW_ARG0_NAME__%'; icm -ScriptBlock ([Scriptblock]::Create((Get-Content -Raw '%~f0'))) -NoNewScope}"`) DO @(
  IF "%%A"=="MVN_CMD" (set __MVNW_CMD__=%%B) ELSE IF "%%B"=="" (echo %%A) ELSE (echo %%A=%%B)
)
@SET PSModulePath=%__MVNW_PSMODULEP_SAVE%
@SET __MVNW_PSMODULEP_SAVE=
@SET __MVNW_ARG0_NAME__=
@SET MVNW_USERNAME=
@SET MVNW_PASSWORD=
@IF NOT "%__MVNW_CMD__%"=="" ("%__MVNW_CMD__%" %*)
@echo Cannot start maven from wrapper >&2 && exit /b 1
@GOTO :EOF
: end batch / begin powershell #>

$ErrorActionPreference = "Stop"
if ($env:MVNW_VERBOSE -eq "true") {
  $VerbosePreference = "Continue"
}

# calculate distributionUrl, requires .mvn/wrapper/maven-wrapper.properties
$distributionUrl = (Get-Content -Raw "$scriptDir/.mvn/wrapper/maven-wrapper.properties" | ConvertFrom-StringData).distributionUrl
if (!$distributionUrl) {
  Write-Error "cannot read distributionUrl property in $scriptDir/.mvn/wrapper/maven-wrapper.properties"
}

switch -wildcard -casesensitive ( $($distributionUrl -replace '^.*/','') ) {
  "maven-mvnd-*" {
    $USE_MVND = $true
    $distributionUrl = $distributionUrl -replace '-bin\.[^.]*$',"-windows-amd64.zip"
    $MVN_CMD = "mvnd.cmd"
    break
  }
  default {
    $USE_MVND = $false
    $MVN_CMD = $script -replace '^mvnw','mvn'
    break
  }
}

# apply MVNW_REPOURL and calculate MAVEN_HOME
# maven home pattern: ~/.m2/wrapper/dists/{apache-maven-<version>,maven-mvnd-<version>-<platform>}/<hash>
if ($env:MVNW_REPOURL) {
  $MVNW_REPO_PATTERN = if ($USE_MVND -eq $False) { "/org/apache/maven/" } else { "/maven/mvnd/" }
  $distributionUrl = "$env:MVNW_REPOURL$MVNW_REPO_PATTERN$($distributionUrl -replace "^.*$MVNW_REPO_PATTERN",'')"
}
$distributionUrlName = $distributionUrl -replace '^.*/',''
$distributionUrlNameMain = $distributionUrlName -replace '\.[^.]*$','' -replace '-bin$',''

$MAVEN_M2_PATH = "$HOME/.m2"
if ($env:MAVEN_USER_HOME) {
  $MAVEN_M2_PATH = "$env:MAVEN_USER_HOME"
}

if (-not (Test-Path -Path $MAVEN_M2_PATH)) {
    New-Item -Path $MAVEN_M2_PATH -ItemType Directory | Out-Null
}

$MAVEN_WRAPPER_DISTS = $null
if ((Get-Item $MAVEN_M2_PATH).Target[0] -eq $null) {
  $MAVEN_WRAPPER_DISTS = "$MAVEN_M2_PATH/wrapper/dists"
} else {
  $MAVEN_WRAPPER_DISTS = (Get-Item $MAVEN_M2_PATH).Target[0] + "/wrapper/dists"
}

$MAVEN_HOME_PARENT = "$MAVEN_WRAPPER_DISTS/$distributionUrlNameMain"
$MAVEN_HOME_NAME = ([System.Security.Cryptography.SHA256]::Create().ComputeHash([byte[]][char[]]$distributionUrl) | ForEach-Object {$_.ToString("x2")}) -join ''
$MAVEN_HOME = "$MAVEN_HOME_PARENT/$MAVEN_HOME_NAME"

if (Test-Path -Path "$MAVEN_HOME" -PathType Container) {
  Write-Verbose "found existing MAVEN_HOME at $MAVEN_HOME"
  Write-Output "MVN_CMD=$MAVEN_HOME/bin/$MVN_CMD"
  exit $?
}

if (! $distributionUrlNameMain -or ($distributionUrlName -eq $distributionUrlNameMain)) {
  Write-Error "distributionUrl is not valid, must end with *-bin.zip, but found $distributionUrl"
}

# prepare tmp dir
$TMP_DOWNLOAD_DIR_HOLDER = New-TemporaryFile
$TMP_DOWNLOAD_DIR = New-Item -Itemtype Directory -Path "$TMP_DOWNLOAD_DIR_HOLDER.dir"
$TMP_DOWNLOAD_DIR_HOLDER.Delete() | Out-Null
trap {
  if ($TMP_DOWNLOAD_DIR.Exists) {
    try { Remove-Item $TMP_DOWNLOAD_DIR -Recurse -Force | Out-Null }
    catch { Write-Warning "Cannot remove $TMP_DOWNLOAD_DIR" }
  }
}

New-Item -Itemtype Directory -Path "$MAVEN_HOME_PARENT" -Force | Out-Null

# Download and Install Apache Maven
Write-Verbose "Couldn't find MAVEN_HOME, downloading and installing it ..."
Write-Verbose "Downloading from: $distributionUrl"
Write-Verbose "Downloading to: $TMP_DOWNLOAD_DIR/$distributionUrlName"

$webclient = New-Object System.Net.WebClient
if ($env:MVNW_USERNAME -and $env:MVNW_PASSWORD) {
  $webclient.Credentials = New-Object System.Net.NetworkCredential($env:MVNW_USERNAME, $env:MVNW_PASSWORD)
}
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
$webclient.DownloadFile($distributionUrl, "$TMP_DOWNLOAD_DIR/$distributionUrlName") | Out-Null

# If specified, validate the SHA-256 sum of the Maven distribution zip file
$distributionSha256Sum = (Get-Content -Raw "$scriptDir/.mvn/wrapper/maven-wrapper.properties" | ConvertFrom-StringData).distributionSha256Sum
if ($distributionSha256Sum) {
  if ($USE_MVND) {
    Write-Error "Checksum validation is not supported for maven-mvnd. `nPlease disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties."
  }
  Import-Module $PSHOME\Modules\Microsoft.PowerShell.Utility -Function Get-FileHash
  if ((Get-FileHash "$TMP_DOWNLOAD_DIR/$distributionUrlName" -Algorithm SHA256).Hash.ToLower() -ne $distributionSha256Sum) {
    Write-Error "Error: Failed to validate Maven distribution SHA-256, your Maven distribution might be compromised. If you updated your Maven version, you need to update the specified distributionSha256Sum property."
  }
}

# unzip and move
Expand-Archive "$TMP_DOWNLOAD_DIR/$distributionUrlName" -DestinationPath "$TMP_DOWNLOAD_DIR" | Out-Null

# Find the actual extracted directory name (handles snapshots where filename != directory name)
$actualDistributionDir = ""

# First try the expected directory name (for regular distributions)
$expectedPath = Join-Path "$TMP_DOWNLOAD_DIR" "$distributionUrlNameMain"
$expectedMvnPath = Join-Path "$expectedPath" "bin/$MVN_CMD"
if ((Test-Path -Path $expectedPath -PathType Container) -and (Test-Path -Path $expectedMvnPath -PathType Leaf)) {
  $actualDistributionDir = $distributionUrlNameMain
}

# If not found, search for any directory with the Maven executable (for snapshots)
if (!$actualDistributionDir) {
  Get-ChildItem -Path "$TMP_DOWNLOAD_DIR" -Directory | ForEach-Object {
    $testPath = Join-Path $_.FullName "bin/$MVN_CMD"
    if (Test-Path -Path $testPath -PathType Leaf) {
      $actualDistributionDir = $_.Name
    }
  }
}

if (!$actualDistributionDir) {
  Write-Error "Could not find Maven distribution directory in extracted archive"
}

Write-Verbose "Found extracted Maven distribution directory: $actualDistributionDir"
Rename-Item -Path "$TMP_DOWNLOAD_DIR/$actualDistributionDir" -NewName $MAVEN_HOME_NAME | Out-Null
try {
  Move-Item -Path "$TMP_DOWNLOAD_DIR/$MAVEN_HOME_NAME" -Destination $MAVEN_HOME_PARENT | Out-Null
} catch {
  if (! (Test-Path -Path "$MAVEN_HOME" -PathType Container)) {
    Write-Error "fail to move MAVEN_HOME"
  }
} finally {
  try { Remove-Item $TMP_DOWNLOAD_DIR -Recurse -Force | Out-Null }
  catch { Write-Warning "Cannot remove $TMP_DOWNLOAD_DIR" }
}

Write-Output "MVN_CMD=$MAVEN_HOME/bin/$MVN_CMD"
</file>

<file path="src/main/java/com/chobbi/server/catalog/dto/CreateProductAttributeDto.java">
package com.chobbi.server.catalog.dto;

import jakarta.validation.constraints.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class CreateProductAttributeDto {
    @NotNull
    private Long id;
    private List<Long> valueIds;
    private List<@NotBlank String> customValues;
}
</file>

<file path="src/main/java/com/chobbi/server/catalog/dto/CreateProductRequest.java">
package com.chobbi.server.catalog.dto;

import jakarta.validation.Valid;
import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotEmpty;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class CreateProductRequest {
    private Long shopId;
    private String name;
    private String description;
    private Long categoryId;
    @Size(min = 1, max = 9)
    private List<CreateProductImages> images;
    @NotEmpty
    @Valid
    private List<CreateProductAttributeDto> attributes;
    @Valid
    @Size(min = 1, max = 2)
    private List<CreateProductTierDto> tiers;
    private List<CreateProductOptionImages> optionImages;
    @Valid
    @Size(min = 1, max = 50)
    private List<CreateProductVariationDto> variations;
}
</file>

<file path="src/main/java/com/chobbi/server/catalog/dto/CreateProductVariationDto.java">
package com.chobbi.server.catalog.dto;

import jakarta.validation.Valid;
import jakarta.validation.constraints.Max;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.util.List;
import java.util.Set;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class CreateProductVariationDto {
    private BigDecimal price;
    private Integer stock;
    private String img;
    @Valid
    @Size(max = 2)
    private List<CreateProductRequestOptionCombination> optionCombination;
}
</file>

<file path="src/main/java/com/chobbi/server/catalog/entity/AttributesEntity.java">
package com.chobbi.server.catalog.entity;

import com.chobbi.server.catalog.enums.AttributeTypesEnums;
import com.chobbi.server.common.BaseEntity;
import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

import java.util.ArrayList;
import java.util.List;

@Getter
@Setter
@Entity(name = "attributes")
public class AttributesEntity extends BaseEntity {
    private String name;
    @Column(name = "is_required")
    private Boolean isRequired;
    @Column(name = "is_custom_allow")
    private Boolean isCustomAllow;
    @Column(name = "is_multiple_allow")
    private Boolean isMultipleAllow;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private AttributeTypesEnums type;

    @ManyToOne
    @JoinColumn(name = "category_id")
    private CategoryEntity categoryEntity;

    @OneToMany(mappedBy = "attributesEntity", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<AttributeValuesEntity> attributeValues = new ArrayList<>();

    @OneToMany(mappedBy = "attributesEntity")
    private List<ProductAttributesEntity> productAttributes = new ArrayList<>();
}
</file>

<file path="src/main/java/com/chobbi/server/catalog/entity/AttributeValuesEntity.java">
package com.chobbi.server.catalog.entity;

import com.chobbi.server.common.BaseEntity;
import jakarta.persistence.*;
import lombok.Data;
import lombok.Getter;
import lombok.Setter;

import java.time.LocalDate;
import java.util.ArrayList;
import java.util.List;

@Getter
@Setter
@Entity(name = "attribute_values")
public class AttributeValuesEntity extends BaseEntity {
    @Column(name = "is_custom")
    private Boolean isCustom;
    @Column(name = "value_text")
    private String valueText;
    @Column(name = "value_number")
    private Double valueNumber;
    @Column(name = "value_boolean")
    private Boolean valueBoolean;
    @Column(name = "value_date")
    private LocalDate valueDate;
    @ManyToOne
    @JoinColumn(name = "attribute_id")
    private AttributesEntity attributesEntity;
    @OneToMany(mappedBy = "attributeValuesEntity")
    private List<ProductAttributesEntity> productAttributes = new ArrayList<>();
}
</file>

<file path="src/main/java/com/chobbi/server/catalog/entity/CategoryEntity.java">
package com.chobbi.server.catalog.entity;

import com.chobbi.server.common.BaseEntity;
import jakarta.persistence.*;
import lombok.Data;

import java.util.ArrayList;
import java.util.List;

@Data
@Entity(name = "category")
public class CategoryEntity extends BaseEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
    private Long parentId;
    @OneToMany(mappedBy = "categoryEntity")
    private List<ProductEntity> productEntities = new ArrayList<>();
    @OneToMany(mappedBy = "categoryEntity", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<AttributesEntity> attributes = new ArrayList<>();
}
</file>

<file path="src/main/java/com/chobbi/server/catalog/entity/ProductAttributesEntity.java">
package com.chobbi.server.catalog.entity;

import com.chobbi.server.common.BaseEntity;
import jakarta.persistence.*;
import lombok.Data;

@Data
@Entity(name = "product_attributes")
public class ProductAttributesEntity extends BaseEntity {

    @ManyToOne
    @JoinColumn(name = "product_id")
    private ProductEntity productEntity;

    @ManyToOne
    @JoinColumn(name = "attribute_id")
    private AttributesEntity attributesEntity;

    @ManyToOne(cascade = {CascadeType.PERSIST, CascadeType.MERGE})
    @JoinColumn(name = "attribute_value_id")
    private AttributeValuesEntity attributeValuesEntity;

}
</file>

<file path="src/main/java/com/chobbi/server/catalog/entity/ProductEntity.java">
package com.chobbi.server.catalog.entity;

import com.chobbi.server.common.BaseEntity;
import com.chobbi.server.entity.ShopEntity;
import com.chobbi.server.enums.StatusEnums;
import jakarta.persistence.*;
import lombok.Data;
import lombok.Getter;
import lombok.Setter;

import java.util.ArrayList;
import java.util.List;

@Getter
@Setter
@Entity(name = "product")
public class ProductEntity extends BaseEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
    private String description;
    private String thumbnail;
    @ManyToOne
    @JoinColumn(name = "shop_id")
    private ShopEntity shopEntity;
    @OneToMany(mappedBy = "productEntity", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<VariationEntity> variations = new ArrayList<>();
    @ManyToOne
    @JoinColumn(name = "category_id")
    private CategoryEntity categoryEntity;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 20)
    private StatusEnums status = StatusEnums.ACTIVE;

    @OneToMany(mappedBy = "productEntity", cascade = CascadeType.ALL)
    private List<TierEntity> tiers = new ArrayList<>();

    @OneToMany(mappedBy = "productEntity", cascade = CascadeType.ALL)
    private List<ProductAttributesEntity> productAttributes = new ArrayList<>();

    @OneToMany(mappedBy = "productEntity", cascade = CascadeType.ALL)
    private List<ProductImagesEntity> productImages = new ArrayList<>();
}
</file>

<file path="src/main/java/com/chobbi/server/catalog/create_product.json">
{
  "name": "Áo thun Zara",
  "shopId": 1,
  "categoryId": 3,
  "description": "dfdfdf",
  "images": [
    {
      "name": "img1.jpg",
      "order": 1
    },
    {
      "name": "img1.jpg",
      "order": 1
    }
  ],
  "attributes": [
    {
      "id": 1,
      "valueIds": [
        1
      ]
    },
    {
      "id": 2,
      "valueIds": [
        5
      ]
    },
    {
      "id": 3,
      "valueIds": [
        10, 11
      ],
      "customValues": [
        "Cotton Custom",
        "Linen Custom"
      ]
    },
    {
      "id": 4,
      "customValues": [
        "2026-01-06"
      ]
    }
  ],
  "tiers": [
    { "name": "Màu sắc",
      "options": ["Trắng", "Đỏ"],
      "hasImages": true
    },
    { "name": "Kích thước",
      "options": ["S", "M", "L"],
      "hasImages": false
    }
  ],
  "optionImages": [
    { "optionName": "Trắng", "imageName": "trang-white.jpg" },
    { "optionName": "Đỏ", "imageName": "do-red.png" }
  ],
  "variations": [
    {
      "price": 10000,
      "stock": 10,
      "img": "img/trang-s.jpg",
      "optionCombination": [
        { "tierName": "Màu sắc", "optionName": "Trắng" },
        { "tierName": "Kích thước", "optionName": "S" }
      ]
    },
    {
      "price": 10000,
      "stock": 10,
      "img": "img/trang-m.jpg",
      "optionCombination": [
        { "tierName": "Màu sắc", "optionName": "Trắng" },
        { "tierName": "Kích thước", "optionName": "M" }
      ]
    },
    {
      "price": 10000,
      "stock": 10,
      "img": "img/trang-l.jpg",
      "optionCombination": [
        { "tierName": "Màu sắc", "optionName": "Trắng" },
        { "tierName": "Kích thước", "optionName": "L" }
      ]
    },
    {
      "price": 10000,
      "stock": 10,
      "img": "img/do-s.jpg",
      "optionCombination": [
        { "tierName": "Màu sắc", "optionName": "Đỏ" },
        { "tierName": "Kích thước", "optionName": "S" }
      ]
    },
    {
      "price": 10000,
      "stock": 10,
      "img": "img/do-m.jpg",
      "optionCombination": [
        { "tierName": "Màu sắc", "optionName": "Đỏ" },
        { "tierName": "Kích thước", "optionName": "M" }
      ]
    },
    {
      "price": 10000,
      "stock": 10,
      "img": "img/do-l.jpg",
      "optionCombination": [
        { "tierName": "Màu sắc", "optionName": "Đỏ" },
        { "tierName": "Kích thước", "optionName": "L" }
      ]
    }
  ]
}
</file>

<file path="src/main/java/com/chobbi/server/controller/CartController.java">

</file>

<file path="src/main/java/com/chobbi/server/dto/ProductDto.java">
package com.chobbi.server.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.ArrayList;
import java.util.List;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class ProductDto {
    private Long id;
    private String name;
    private List<TierDto> tiers = new ArrayList<>();
    private List<VariationDto> variations = new ArrayList<>();
    private List<CategoryDto> categories  = new ArrayList<>();
}
</file>

<file path="src/main/java/com/chobbi/server/entity/CartEntity.java">
package com.chobbi.server.entity;

import com.chobbi.server.common.BaseEntity;
import jakarta.persistence.*;
import lombok.Data;

@Data
@Entity(name = "cart")
public class CartEntity extends BaseEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    @OneToOne
    @JoinColumn(name = "account_id")
    private AccountEntity accountEntity;
}
</file>

<file path="src/main/java/com/chobbi/server/entity/CartVariationEntity.java">
package com.chobbi.server.entity;

import com.chobbi.server.catalog.entity.VariationEntity;
import com.chobbi.server.common.BaseEntity;
import jakarta.persistence.*;
import lombok.Data;

import java.math.BigDecimal;

@Data
@Entity(name = "cart_variation")
public class CartVariationEntity extends BaseEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private Integer quantity;
    @Column(name = "price_at_time")
    private BigDecimal priceAtTime;

    @ManyToOne
    @JoinColumn(name = "cart_id")
    private CartEntity cartEntity;

    @ManyToOne
    @JoinColumn(name = "variation_id")
    private VariationEntity variationEntity;
}
</file>

<file path="src/main/java/com/chobbi/server/entity/RolesEntity.java">
package com.chobbi.server.entity;

import com.chobbi.server.common.BaseEntity;
import jakarta.persistence.*;
import lombok.Data;

@Data
@Entity(name = "roles")
public class RolesEntity extends BaseEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
}
</file>

<file path="src/main/java/com/chobbi/server/enums/StatusEnums.java">
package com.chobbi.server.enums;

public enum StatusEnums {
    ACTIVE,
    INACTIVE,
}
</file>

<file path="src/main/java/com/chobbi/server/repo/CartVariationRepo.java">
package com.chobbi.server.repo;

import com.chobbi.server.entity.CartEntity;
import com.chobbi.server.entity.CartVariationEntity;
import com.chobbi.server.catalog.entity.VariationEntity;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;
import java.util.Optional;

public interface CartVariationRepo extends JpaRepository<CartVariationEntity, Long> {
    Optional<CartVariationEntity> findByCartEntityAndVariationEntity(CartEntity cart, VariationEntity variation);
    List<CartVariationEntity> findAllByCartEntity(CartEntity cart);
}
</file>

<file path="src/main/java/com/chobbi/server/repo/ShopRepo.java">
package com.chobbi.server.repo;

import com.chobbi.server.entity.ShopEntity;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface ShopRepo extends JpaRepository<ShopEntity, Long> {
    Optional<ShopEntity> findByIdAndDeletedAtIsNull(Long id);
}
</file>

<file path="src/main/java/com/chobbi/server/catalog/controller/ProductController.java">
package com.chobbi.server.catalog.controller;

import com.chobbi.server.catalog.dto.CreateProductRequest;
import com.chobbi.server.catalog.services.ProductServices;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

@RestController
@RequestMapping("/product")
@RequiredArgsConstructor
public class ProductController {
    private final ProductServices productServices;

//    @GetMapping(params = {"shopId", "productId"})
//    public ResponseEntity<?> getProduct(@RequestParam Long shopId, @RequestParam Long productId) {
//        return ResponseEntity.ok(productServices.getProduct(shopId, productId));
//    }

    @PostMapping(
            value = "/create",
            consumes = MediaType.MULTIPART_FORM_DATA_VALUE
    )
    public ResponseEntity<?> createProduct(
            @RequestPart("product") @Valid CreateProductRequest productRequest,
            @RequestPart(value = "images", required = false) MultipartFile[] media
    ) {
        productServices.createProduct(productRequest, media);
        return ResponseEntity.ok("ok");
    }
    @GetMapping(params = "productId")
    public ResponseEntity<?> getProduct(@RequestParam Long productId) {
        return ResponseEntity.ok("ffff");
    }
//    @PostMapping("/update")
//    public ResponseEntity<?> updateProduct(@RequestBody ProductRequest productRequest) {
//        return ResponseEntity.ok(productServices.updateProduct(productRequest));
//    }
//    @PostMapping("/delete")
//    public void deleteProduct(@RequestParam Long shopId, @RequestParam Long productId) {
//        productServices.deleteProduct(shopId, productId);
//    }
}
</file>

<file path="src/main/java/com/chobbi/server/entity/AccountEntity.java">
package com.chobbi.server.entity;

import com.chobbi.server.common.BaseEntity;
import jakarta.persistence.*;
import lombok.Data;

@Data
@Entity(name = "account")
public class AccountEntity extends BaseEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String email;
    private String name;
    private String pwd;
}
</file>

<file path="src/main/java/com/chobbi/server/repo/CategoryRepo.java">
package com.chobbi.server.repo;

import com.chobbi.server.catalog.entity.CategoryEntity;
import org.springframework.data.jpa.repository.JpaRepository;

public interface CategoryRepo extends JpaRepository<CategoryEntity, Long> {
    boolean existsByParentId(Long parentId);
}
</file>

<file path="src/main/java/com/chobbi/server/repo/OptionsRepo.java">
package com.chobbi.server.repo;

import com.chobbi.server.catalog.entity.OptionsEntity;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface OptionsRepo extends JpaRepository<OptionsEntity, Long> {
    List<OptionsEntity> findAllByIdInAndDeletedAtIsNull(List<Long> optionIds);
}
</file>

<file path="src/main/java/com/chobbi/server/repo/TierRepo.java">
package com.chobbi.server.repo;

import com.chobbi.server.catalog.entity.TierEntity;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface TierRepo extends JpaRepository<TierEntity, Long> {
    List<TierEntity> findAllByIdInAndDeletedAtIsNull(List<Long> tierIds);
    List<TierEntity> findAllByProductEntity_IdAndDeletedAtIsNull(Long productId);
}
</file>

<file path="src/main/java/com/chobbi/server/repo/VariationRepo.java">
package com.chobbi.server.repo;

import com.chobbi.server.catalog.entity.VariationEntity;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface VariationRepo extends JpaRepository<VariationEntity, Long> {
    List<VariationEntity> findAllByProductEntity_IdAndDeletedAtIsNull(Long productId);
    List<VariationEntity> findAllByProductEntity_Id(Long productId);
    Optional<VariationEntity> findByIdAndDeletedAtIsNull(Long variationId);
}
</file>

<file path="src/main/resources/application.yml">
server:
  port: 9090

spring:
  datasource:
    url: ${DATASOURCE_URL:jdbc:mysql://localhost:3307/chobbi}
    username: ${DATASOURCE_USERNAME:root}
    password: ${DATASOURCE_PASSWORD:admin123}

  jpa:
    database-platform: org.hibernate.dialect.MySQL8Dialect
    hibernate:
      ddl-auto: none

#    show-sql: true
#    properties:
#      hibernate:
#        format_sql: true

  servlet:
    multipart:
      max-file-size: 10MB
      max-request-size: 100MB

logging:
  level:
    org.hibernate.SQL: DEBUG
    org.hibernate.orm.jdbc.bind: TRACE
file:
  root-path: /Users/matthew777/Desktop/spring-upload-demo
  base-domain: http://localhost:9090/static
</file>

<file path="src/main/java/com/chobbi/server/entity/ShopEntity.java">
package com.chobbi.server.entity;

import com.chobbi.server.catalog.entity.ProductEntity;
import com.chobbi.server.common.BaseEntity;
import com.chobbi.server.enums.StatusEnums;
import jakarta.persistence.*;
import lombok.Data;

import java.util.ArrayList;
import java.util.List;

@Data
@Entity(name = "shop")
public class ShopEntity extends BaseEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
    @OneToMany(mappedBy = "shopEntity")
    private List<ProductEntity> products = new ArrayList<>();
    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 20)
    private StatusEnums status = StatusEnums.ACTIVE;
}
</file>

<file path="src/main/java/com/chobbi/server/repo/ProductRepo.java">
package com.chobbi.server.repo;

import com.chobbi.server.catalog.entity.ProductEntity;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface ProductRepo extends JpaRepository<ProductEntity, Long> {
    Optional<ProductEntity> findByIdAndShopEntity_IdAndDeletedAtIsNull(Long productId, Long shopId);
    List<ProductEntity> findAllByShopEntity_IdAndDeletedAtIsNull(Long shopId);
    Optional<ProductEntity> findByIdAndDeletedAtIsNull(Long productId);
}
</file>

<file path="src/main/java/com/chobbi/server/repo/VariationOptionRepo.java">
package com.chobbi.server.repo;

import com.chobbi.server.catalog.entity.VariationOptionEntity;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;

public interface VariationOptionRepo extends JpaRepository<VariationOptionEntity, Long> {
    List<VariationOptionEntity> findByVariationEntity_Id(Long productId);
    List<VariationOptionEntity> findAllByVariationEntity_IdIn(List<Long> variantIds);

}
</file>

<file path="pom.xml">
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
	<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>3.5.5</version>
		<relativePath/> <!-- lookup parent from repository -->
	</parent>
	<groupId>com.chobbi</groupId>
	<artifactId>server</artifactId>
	<version>0.0.1-SNAPSHOT</version>
	<packaging>jar</packaging>
	<name>server</name>
	<description>Demo project for Spring Boot</description>
	<url/>
	<licenses>
		<license/>
	</licenses>
	<developers>
		<developer/>
	</developers>
	<scm>
		<connection/>
		<developerConnection/>
		<tag/>
		<url/>
	</scm>
	<properties>
		<java.version>21</java.version>
		<maven.compiler.source>21</maven.compiler.source>
		<maven.compiler.target>21</maven.compiler.target>
	</properties>
	<dependencies>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-jpa</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-redis</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-security</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-validation</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>

		<dependency>
			<groupId>com.mysql</groupId>
			<artifactId>mysql-connector-j</artifactId>
			<scope>runtime</scope>
		</dependency>
		<dependency>
			<groupId>org.projectlombok</groupId>
			<artifactId>lombok</artifactId>
			<optional>true</optional>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
		</dependency>
		<dependency>
			<groupId>org.springframework.security</groupId>
			<artifactId>spring-security-test</artifactId>
			<scope>test</scope>
		</dependency>
		<dependency>
			<groupId>io.jsonwebtoken</groupId>
			<artifactId>jjwt-api</artifactId>
			<version>0.12.6</version>
		</dependency>
		<dependency>
			<groupId>io.jsonwebtoken</groupId>
			<artifactId>jjwt-impl</artifactId>
			<version>0.12.6</version>
			<scope>runtime</scope>
		</dependency>
		<dependency>
			<groupId>io.jsonwebtoken</groupId>
			<artifactId>jjwt-jackson</artifactId> <!-- or jjwt-gson if Gson is preferred -->
			<version>0.12.6</version>
			<scope>runtime</scope>
		</dependency>
		<dependency>
			<groupId>com.google.guava</groupId>
			<artifactId>guava</artifactId>
			<version>33.4.0-jre</version>
		</dependency>
	</dependencies>

	<build>
		<plugins>
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-compiler-plugin</artifactId>
				<configuration>
					<annotationProcessorPaths>
						<path>
							<groupId>org.projectlombok</groupId>
							<artifactId>lombok</artifactId>
						</path>
					</annotationProcessorPaths>
				</configuration>
			</plugin>
			<plugin>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-maven-plugin</artifactId>
				<configuration>
					<excludes>
						<exclude>
							<groupId>org.projectlombok</groupId>
							<artifactId>lombok</artifactId>
						</exclude>
					</excludes>
				</configuration>
			</plugin>
		</plugins>
	</build>

</project>
</file>

</files>
